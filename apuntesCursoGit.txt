Curso GIT

PRIMERA CLASE

GIT --> Sistema de control de versiones, para ver quien hizo los cambios el tiempo y qué hizo

Creado por linux (Linus torbals)

Instalar GIT en la página, tener en cuenta GIT bash

En la carpeta que se va a subir

---> git init, crea carpeta oculta de la base de datos (cambios atómicos) o que se van a cambiar automáticamente

---> git status, se va  a ver el estado del proyecto, busca el contenido de la carpeta

---> git add nombre_archivo , añade el archivo al repositorio, ya luego al hacer status se puede incluir---> nos dice que hay cambios que deben ser enviados---> se manda a la memoria ram

---> git rm nombre_archivo, cambia el estado lo remueve

---> git commit -m "Añadir comentario" --> se sube los archivos al repositorios, solo si están añadidos con el comando add en cache

---> git config --> configuracion de git

---> git config --list ---> la lista de cosas que faltan por configurar

---> git config --global user.name "nombre" --> configuramos el nombre de usuario que se tiene en el repositorios

---> git config --global user.email "email" --> configuramos el email que se tiene en el repositorios

---> git log nombre_archivo ---> miramos los registros, cambios realizados sobre el archivo (head master) cambio más reciente

--> git log --stat --> cambios especificos a los archivos

--->git show nombre_archivo --> cambios hechos en el archivo

----> git diff copiar_indicador_commit_1(version mas nueva) copiar_indicador_commit_2(version mas vieja) --> compara la diferencia en la base de datos de los dos commits generados

QUE PASA CUANDO SE HACE GIT init (archivos untrack)

---> Se crea un area en memoria RAM llamda staging --> cambios
---> Se crea el repositorio .git (cambios de archivos)

GIT ADD (archivo track) --> revisa si hay cambios, se va a staging

El archivo pasa a la RAM (Staging) y quueda esperando para enviarlo al repositorio

GIT commit (archivo track)--> en el repositorio

Se envía el archivo del Staging al repositorio (al master)

BRANCHES (RAMAS)

Se tiene un branch llamada master y los commit se van actualizando ahí

Se hacen múltiples ramas para ir verificando archivos sin cambiar el original o master

Igual se hace merge entre ramas

RESET

    --> git reset versio_a_la_que_queremos_devolvernos -- hard --> todo vuelve al estado anterior, se borran inclusive los logs
--> git reset versio_a_la_que_queremos_devolvernos -- soft --> lo que está en staging (RAM cuando se da add) sigue en staging

CHECKOUT

--> git checkout version_a_la_que_queremos_devolvernos nombre_del_archivo.xxx ---> devuelve el cambio anterior o version anterior


DIFERENCIA  RM Y RESET

git rm ---> se elimina el archivo, pero es posible recuperarlo. Solo es necesario viajar en el tiempo y acceder a este

Formas de eliminar los archivos:

git rm --cached :Elimina los archivos del repositorio local (área de staging) pero lo mantiene en el disco duro. Pasaran a estado untracked

git rm --forced: Elimina los archivos del disco duro, es posible recuperarlos con comandos avanzados

GIT RESET:

con git reset -- hard--> se borra todo sin posibilidad de recuperarlo

git reset --soft --> borramos los archivos de staging

git reset HEAD --> borramos los archivos de staging


TRACKED AND untracked

Se dice que un archivo es tracked, cuando está en staging, es decir cuando se hace git add . Porque git va a percibir los cambios con git status

Si no está en staging, no serán trackeados los archivos, quedaran en untracked

Enviar al repositorio (todo en staging)---> commit

SERVIDOR REMOTO

git clone url -->es como el git init, se clona con el link. Una copia del master y una base de datos de todos los cambios históricos

git push --> se envía todo lo del repositorio al servidor REMOTO

git fetch --> Se trae al repositorio local pero no lo copia a los archivos

git merge --> se unen los archivos

git pull --> copio el repoistorio y lo uno a este

git commit -am "comentario"--> agrega al repositorio los archivos que se hayan modificado (traacked)

CREAR UNA RAMA -BRANCHES

git branch nombre_de_la_rama --> crea una nueva rama sobre el head

git checkout nombre_de_la_rama --> nos movemos a esa rama

HEAD

Es el apuntador en donde haré el commit, a qué rama se apunta --> checkout, todos los archivos cambian al último commit donde apunto 


git clone url ---> Se copia el master a la carpeta, la base de datos de todos los cambios históricos

git pull --> copio el repositorio local y copio el directorio

Las ramas van cambiando de commits, según la branch

Cuando se hace merge, se elimina la rama y se mezcla en master


NOTA: Para hacer merge, tiene que hacerse desde MASTER, porque lo que se hace es traer los archivos de la cabecera a master
Se le da final a la rama y se continua con master
